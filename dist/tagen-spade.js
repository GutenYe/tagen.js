minispade.register('./array', "(function() {var __slice = Array.prototype.slice;\n\nArray.toArray = function(iterable) {\n  if (!iterable) return [];\n  if (iterable.toArray) return iterable.toArray();\n  if (_.isArray(iterable)) return slice.call(iterable);\n  if (_.isArguments(iterable)) return slice.call(iterable);\n  return _.values(iterable);\n};\n\n_.mixin(Array, Enumerable);\n\n_.reopen(Array, {\n  _each: function(iterator) {\n    var i, v, _len, _results;\n    if (!iterator) return new Enumerator(this);\n    try {\n      _results = [];\n      for (i = 0, _len = this.length; i < _len; i++) {\n        v = this[i];\n        _results.push(iterator(v, i, this));\n      }\n      return _results;\n    } catch (err) {\n      if (err !== BREAKER) throw err;\n    }\n  },\n  _isEqual: function(ary) {\n    var i, v, _len;\n    if (this.length !== ary.length) return false;\n    for (i = 0, _len = this.length; i < _len; i++) {\n      v = this[i];\n      if (_(v).instanceOf(Array)) {\n        return v._isEqual(ary[i]);\n      } else {\n        if (v !== ary[i]) return false;\n      }\n    }\n    return true;\n  },\n  _isInclude: function(obj) {\n    return this.indexOf(obj) !== -1;\n  },\n  _isEmpty: function() {\n    return this.length === 0;\n  },\n  _clone: function() {\n    return this.slice();\n  },\n  _random: function() {\n    var i;\n    i = Math.random() * this.length;\n    return this[Math.floor(i)];\n  },\n  _zip: function() {\n    var args, i, length, ret;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    args = [this].concat(__slice.call(args));\n    length = args._pluck('length')._max();\n    ret = new Array(length);\n    for (i = 0; 0 <= length ? i < length : i > length; 0 <= length ? i++ : i--) {\n      ret[i] = args._pluck(\"\" + i);\n    }\n    return ret;\n  },\n  _first: function(n) {\n    if (n) {\n      return this.slice(0, n);\n    } else {\n      return this[0];\n    }\n  },\n  _last: function(n) {\n    if (n) {\n      return this.slice(this.length - n);\n    } else {\n      return this[this.length - 1];\n    }\n  },\n  _compact: function() {\n    return this._findAll(function(value) {\n      return value !== null;\n    });\n  },\n  _flatten: function(shallow) {\n    var ret;\n    ret = [];\n    this._each(function(v) {\n      if (_(v).instanceOf(Array)) {\n        v = shallow ? v : v._flatten();\n        return ret = ret.concat(v);\n      } else {\n        return ret.push(v);\n      }\n    });\n    return ret;\n  },\n  _uniq: function(isSorted) {\n    var ret;\n    ret = [];\n    this._each(function(v, i) {\n      if (0 === i || (isSorted === true ? ret._last() !== v : !ret._isInclude(v))) {\n        ret.push(v);\n      }\n      return ret;\n    });\n    return ret;\n  },\n  _without: function() {\n    var args;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return this._findAll(function(value) {\n      return !args._isInclude(value);\n    });\n  },\n  _pluck: function(key) {\n    return this._map(function(data) {\n      return data[key];\n    });\n  },\n  _findIndex: function(obj) {\n    var iterator, ret;\n    switch (_(obj).constructorName()) {\n      case 'Function':\n        iterator = obj;\n        break;\n      default:\n        iterator = function(v) {\n          return v === obj;\n        };\n    }\n    ret = -1;\n    this._each(function(v, i, self) {\n      if (iterator(v, i, self)) {\n        ret = i;\n        throw BREAKER;\n      }\n    });\n    return ret;\n  },\n  _invoke: function() {\n    var args, methodName;\n    methodName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    return this._map(function(value) {\n      var method;\n      method = value[methodName];\n      if (method) {\n        return method.apply.apply(method, [value].concat(__slice.call(args)));\n      } else {\n        return null;\n      }\n    });\n  },\n  _indexOf: Array.prototype.indexOf || function(item, isSorted) {\n    var i, k, _len;\n    if (this === null) return -1;\n    if (isSorted) {\n      i = _.sortedIndex(this, item);\n      if (this[i] === item) {\n        return i;\n      } else {\n        return -1;\n      }\n    }\n    for (i = 0, _len = this.length; i < _len; i++) {\n      k = this[i];\n      if (k === item) return i;\n    }\n    return -1;\n  },\n  _lastIndexOf: Array.prototype.lastIndexOf || function(item) {\n    var i;\n    if (this === null) return -1;\n    i = this.length;\n    while (i--) {\n      if (this[i] === item) return i;\n    }\n    return -1;\n  },\n  _transpose: function() {\n    var h, i, j, ret, w;\n    w = this.length;\n    h = this[0] instanceof Array ? this[0].length : 0;\n    if (h === 0 || w === 0) return [];\n    ret = [];\n    i = 0;\n    while (i < h) {\n      ret[i] = [];\n      j = 0;\n      while (j < w) {\n        ret[i][j] = this[j][i];\n        j++;\n      }\n      i++;\n    }\n    return ret;\n  }\n});\n\nArray.prototype._contains = Array.prototype._isInclude;\n\n_.under_alias(Array, \"push\", \"pop\", \"concat\", \"slice\", \"sort\", \"reverse\", \"join\", \"splice\");\n\n})();\n//@ sourceURL=./array");minispade.register('./core', "(function() {var BREAKER, Wrapper, eq, exports, idCounter, root, _,\n  __hasProp = Object.prototype.hasOwnProperty,\n  __slice = Array.prototype.slice;\n\n_ = function(obj) {\n  return new Wrapper(obj);\n};\n\n_.VERSION = '0.0.1';\n\nBREAKER = new Error('BREAKER');\n\nroot = this.root = this;\n\nif (typeof exports !== \"undefined\" && exports !== null) {\n  exports = _;\n} else {\n  root['_'] = _;\n}\n\nif (typeof global !== \"undefined\" && global !== null) {\n  global['BREAKER'] = BREAKER;\n} else {\n  root['BREAKER'] = BREAKER;\n}\n\n_.reopenClass = function(klass, attrs, overwrite) {\n  var k, v, _results;\n  _results = [];\n  for (k in attrs) {\n    if (!__hasProp.call(attrs, k)) continue;\n    v = attrs[k];\n    if (!klass[k]) {\n      _results.push(Object.defineProperty(klass, k, {\n        value: v,\n        writable: true\n      }));\n    } else {\n      _results.push(void 0);\n    }\n  }\n  return _results;\n};\n\n_.reopen = _.mixin = function(klass, attrs, overwrite) {\n  var k, target, v, _results;\n  target = klass.prototype;\n  _results = [];\n  for (k in attrs) {\n    if (!__hasProp.call(attrs, k)) continue;\n    v = attrs[k];\n    if (target[k] && !overwrite) {} else {\n      _results.push(target[k] = v);\n    }\n  }\n  return _results;\n};\n\n_[\"try\"] = function() {\n  var args, method, obj, _ref;\n  obj = arguments[0], method = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];\n  if (obj === null) return null;\n  if (obj[method]) {\n    return (_ref = obj[method]).call.apply(_ref, [obj].concat(__slice.call(args)));\n  }\n  return null;\n};\n\nidCounter = 0;\n\n_.uniqueId = function(prefix) {\n  var id;\n  id = idCounter++;\n  if (prefix) {\n    return \"\" + prefix + id;\n  } else {\n    return \"\" + id;\n  }\n};\n\n_.escape = function(str) {\n  str = str.toString();\n  return str.replace(/&(?!\\w+;|#\\d+;|#x[\\da-f]+;)/gi, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g, '&#x2F;');\n};\n\n_.isEqual = function(a, b) {\n  return eq(a, b, []);\n};\n\neq = function(a, b, stack) {\n  var isBooleanA, isBooleanB, isDateA, isDateB, isNumberA, isNumberB, isRegExpA, isRegExpB, isStringA, isStringB, key, length, result, size, typeA, _ref, _ref2, _ref3, _ref4, _ref5, _ref6;\n  if (a === b) return a !== 0 || 1 / a === 1 / b;\n  if ((a === null) || (b === null)) return a === b;\n  if (a.isEqual && _(a.isEqual).instanceOf(Function)) return a.isEqual(b);\n  if (b.isEqual && _(b.isEqual).instanceOf(Function)) return b.isEqual(a);\n  typeA = typeof a;\n  if (typeA !== typeof b) return false;\n  if (!a !== !b) return false;\n  if (_(a).isNaN()) return _(b).isNaN();\n  _ref = [_(a).instanceOf(String), _(b).instanceOf(String)], isStringA = _ref[0], isStringB = _ref[1];\n  if (isStringA || isStringB) {\n    return isStringA && isStringB && String(a) === String(b);\n  }\n  _ref2 = [_(a).instanceOf(Number), _(b).instanceOf(Number)], isNumberA = _ref2[0], isNumberB = _ref2[1];\n  if (isNumberA || isNumberB) return isNumberA && isNumberB && +a === +b;\n  _ref3 = [_(a).instanceOf(Boolean), _(b).instanceOf(Boolean)], isBooleanA = _ref3[0], isBooleanB = _ref3[1];\n  if (isBooleanA || isBooleanB) return isBooleanA && isBooleanB && +a === +b;\n  _ref4 = [_(a).instanceOf(Date), _(b).instanceOf(Date)], isDateA = _ref4[0], isDateB = _ref4[1];\n  if (isDateA || isDateB) return isDateA && isDateB && a.getTime() === b.getTime();\n  _ref5 = [_(a).instanceOf(RegExp), _(b).instanceOf(RegExp)], isRegExpA = _ref5[0], isRegExpB = _ref5[1];\n  if (isRegExpA || isRegExpB) {\n    return isRegExpA && isRegExpB && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;\n  }\n  if (typeA !== 'object') return false;\n  if (a.length !== b.length) return false;\n  if (a.constructor !== b.constructor) return false;\n  length = stack.length;\n  while (length--) {\n    if (stack[length] === a) return true;\n  }\n  stack.push(a);\n  _ref6 = [0, true], size = _ref6[0], result = _ref6[1];\n  for (key in a) {\n    if (!__hasProp.call(a, key)) continue;\n    size++;\n    if (!(result = hasOwnProperty.call(b, key) && eq(a[key], b[key], stack))) {\n      break;\n    }\n  }\n  if (result) {\n    for (key in b) {\n      if (hasOwnProperty.call(b, key) && !size--) break;\n    }\n    result = !size;\n  }\n  stack.pop();\n  return result;\n};\n\nWrapper = (function() {\n\n  function Wrapper(obj) {\n    this.object = obj;\n  }\n\n  Wrapper.prototype.reopen = function(attrs) {\n    var k, v, _results;\n    _results = [];\n    for (k in attrs) {\n      if (!__hasProp.call(attrs, k)) continue;\n      v = attrs[k];\n      _results.push(this.object[k] = v);\n    }\n    return _results;\n  };\n\n  Wrapper.prototype.constructorName = function() {\n    var results;\n    if (Object.prototype.toString.call(this.object) === '[object Arguments]') {\n      return 'Arguments';\n    } else {\n      results = this.object.constructor.toString().match(/function (.{1,})\\(/);\n      if (results && results.length > 1) {\n        return results[1];\n      } else {\n        return '';\n      }\n    }\n  };\n\n  Wrapper.prototype.instanceOf = function(constructorClass) {\n    if (constructorClass === 'Arguments' && Object.prototype.toString.call(this.object) === '[object Arguments]') {\n      return true;\n    } else {\n      return this.object.constructor === constructorClass;\n    }\n  };\n\n  Wrapper.prototype.isNaN = function() {\n    return this.object !== this.object;\n  };\n\n  Wrapper.prototype.tap = function(interceptor) {\n    interceptor(this.object);\n    return this;\n  };\n\n  Wrapper.prototype.clone = function() {\n    var prop, ret;\n    ret = {};\n    for (prop in this.object) {\n      ret[prop] = this.object[prop];\n    }\n    return ret;\n  };\n\n  Wrapper.prototype.methods = function() {\n    var k, names, v, _ref;\n    names = [];\n    _ref = this.object;\n    for (k in _ref) {\n      v = _ref[k];\n      if (_(v).instanceOf(Function)) names.push(k);\n    }\n    return names.sort();\n  };\n\n  return Wrapper;\n\n})();\n\n_.under_alias = function() {\n  var klass, name, names, under_name, _i, _len, _results;\n  klass = arguments[0], names = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  _results = [];\n  for (_i = 0, _len = names.length; _i < _len; _i++) {\n    name = names[_i];\n    under_name = \"_\" + name;\n    _results.push(klass.prototype[under_name] = klass.prototype[name]);\n  }\n  return _results;\n};\n\n_.prototype = Wrapper.prototype;\n\n})();\n//@ sourceURL=./core");minispade.register('./enumerable', "(function() {var Enumerable,\n  __slice = Array.prototype.slice;\n\nEnumerable = {\n  _any: function(iterator) {\n    var ret;\n    ret = false;\n    this._each(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (ret |= iterator.apply(null, args)) return true;\n    });\n    return !!ret;\n  },\n  _all: function(iterator) {\n    var ret;\n    ret = true;\n    this._each(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (!iterator.apply(null, args)) {\n        ret = false;\n        throw BREAKER;\n      }\n    });\n    return ret;\n  },\n  _none: function(iterator) {\n    var ret;\n    ret = true;\n    this._each(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (iterator.apply(null, args)) {\n        ret = false;\n        throw BREAKER;\n      }\n    });\n    return ret;\n  },\n  _one: function(iterator) {\n    var counts;\n    counts = 0;\n    this._each(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (iterator.apply(null, args)) {\n        counts += 1;\n        if (counts === 2) throw BREAKER;\n      }\n    });\n    if (counts === 1) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n  _map: function(iterator) {\n    var ret,\n      _this = this;\n    ret = [];\n    this._each(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return ret.push(iterator.apply(null, args));\n    });\n    return ret;\n  },\n  _find: function(iterator) {\n    var ret,\n      _this = this;\n    ret = null;\n    this._each(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (iterator.apply(null, args)) {\n        ret = _(_this).instanceOf(Hash) ? [args[0], args[1]] : args[0];\n        throw BREAKER;\n      }\n    });\n    return ret;\n  },\n  _findAll: function(iterator) {\n    var ret,\n      _this = this;\n    ret = [];\n    this._each(function() {\n      var args, value;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (iterator.apply(null, args)) {\n        value = _(_this).instanceOf(Hash) ? [args[0], args[1]] : args[0];\n        return ret.push(value);\n      }\n    });\n    return ret;\n  },\n  _reject: function(iterator) {\n    var ret,\n      _this = this;\n    ret = [];\n    this._each(function() {\n      var args, value;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (!iterator.apply(null, args)) {\n        value = _(_this).instanceOf(Hash) ? [args[0], args[1]] : args[0];\n        return ret.push(value);\n      }\n    });\n    return ret;\n  },\n  _inject: function() {\n    var args, initial, iterator, memo;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    switch (args.length) {\n      case 1:\n        initial = null;\n        iterator = args[0];\n        break;\n      case 2:\n        initial = args[0];\n        iterator = args[1];\n        break;\n      default:\n        throw \"Enumerable#_inject: wrong argument -- \" + args;\n    }\n    memo = initial;\n    this._each(function(value) {\n      if (initial === null) {\n        memo = value;\n        return initial = true;\n      } else {\n        return memo = iterator(memo, value);\n      }\n    });\n    return memo;\n  },\n  _sum: function() {\n    var args, callback, initial;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    switch (args.length) {\n      case 1:\n        if (typeof args[0] === \"function\") {\n          initial = 0;\n          callback = args[0];\n        } else {\n          initial = args[0];\n          callback = function(v) {\n            return v;\n          };\n        }\n        break;\n      case 2:\n        initial = args[0];\n        callback = args[1];\n        break;\n      default:\n        throw \"Enumerable#_sum: wrong argument -- \" + args;\n    }\n    return this._inject(initial, function(memo, v) {\n      return memo + callback.call(this, v);\n    });\n  },\n  _max: function() {\n    if (this._isEmpty()) {\n      return null;\n    } else if (_(this).instanceOf(Array)) {\n      return Math.max.apply(Math, this);\n    }\n  },\n  _min: function(iterator) {\n    if (this._isEmpty()) {\n      return null;\n    } else if (_(this).instanceOf(Array)) {\n      return Math.min.apply(Math, this);\n    }\n  },\n  _shuffle: function() {\n    var rand, shuffled, _ref;\n    _ref = [[], null], shuffled = _ref[0], rand = _ref[1];\n    this._each(function(value, index) {\n      if (index === 0) {\n        return shuffled[0] = value;\n      } else {\n        rand = Math.floor(Math.random() * (index + 1));\n        shuffled[index] = shuffled[rand];\n        return shuffled[rand] = value;\n      }\n    });\n    return shuffled;\n  },\n  _sortBy: function(iterator) {\n    var ret;\n    ret = (this._map(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return {\n        value: args[0],\n        criteria: iterator.apply(null, args)\n      };\n    })).sort(function(a, b) {\n      var _ref;\n      _ref = [a.criteria, b.criteria], a = _ref[0], b = _ref[1];\n      if (a < b) {\n        return -1;\n      } else if (a > b) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    return ret._pluck(\"value\");\n  },\n  _groupBy: function(iterator) {\n    var ret,\n      _this = this;\n    ret = H();\n    this._each(function() {\n      var args, key, value;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      key = iterator.apply(null, args);\n      value = _(_this).instanceOf(Hash) ? [args[0], args[1]] : args[0];\n      return ret._fetch_or_store(key, []).push(value);\n    });\n    return ret;\n  },\n  _eachSlice: function(n, callback) {\n    var end, parts,\n      _this = this;\n    if (n === 0) return [];\n    parts = this.length._div(n) + 1;\n    end = 0;\n    return parts._times(1, function(i) {\n      var start, _ref;\n      _ref = [end, n * i], start = _ref[0], end = _ref[1];\n      return callback.call(_this, _this.slice(start, end));\n    });\n  },\n  _eachCons: function(n, callback) {\n    var data, start, _results;\n    if (n === 0) return [];\n    start = 0;\n    _results = [];\n    while (true) {\n      data = this.slice(start, (start + n));\n      if (data.length < n) break;\n      callback.call(this, data);\n      _results.push(start += 1);\n    }\n    return _results;\n  }\n};\n\nroot[\"Enumerable\"] = Enumerable;\n\nEnumerable._collect = Enumerable._map;\n\nEnumerable._detect = Enumerable._find;\n\n})();\n//@ sourceURL=./enumerable");minispade.register('./enumerator', "(function() {var Enumerator,\n  __slice = Array.prototype.slice;\n\nEnumerator = (function() {\n\n  function Enumerator(data) {\n    this.data = data;\n  }\n\n  Enumerator.prototype._with_object = function(memo, iterator) {\n    this.data._each(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return iterator.apply(null, [memo].concat(__slice.call(args)));\n    });\n    return memo;\n  };\n\n  Enumerator.prototype._each = function() {\n    var args, _ref;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return (_ref = this.data)._each.apply(_ref, args);\n  };\n\n  return Enumerator;\n\n})();\n\nroot['Enumerator'] = Enumerator;\n\n})();\n//@ sourceURL=./enumerator");minispade.register('./hash', "(function() {var H, Hash,\n  __hasProp = Object.prototype.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };\n\nHash = (function(_super) {\n\n  __extends(Hash, _super);\n\n  function Hash(data) {\n    var k, v;\n    this.data = new Object;\n    if (data) {\n      for (k in data) {\n        if (!__hasProp.call(data, k)) continue;\n        v = data[k];\n        this.data[k] = v;\n      }\n    }\n  }\n\n  Hash.prototype._each = function(iterator) {\n    var k, v, _ref, _results;\n    try {\n      _ref = this.data;\n      _results = [];\n      for (k in _ref) {\n        if (!__hasProp.call(_ref, k)) continue;\n        v = _ref[k];\n        _results.push(iterator(k, v, this.data));\n      }\n      return _results;\n    } catch (err) {\n      if (err !== BREAKER) throw err;\n    }\n  };\n\n  Hash.prototype._isEmpty = function() {\n    var k, v, _ref;\n    _ref = this.data;\n    for (k in _ref) {\n      if (!__hasProp.call(_ref, k)) continue;\n      v = _ref[k];\n      return false;\n    }\n  };\n\n  Hash.prototype._keys = function() {\n    return Object.keys(this.data);\n  };\n\n  Hash.prototype._values = function() {\n    var k, ret, _i, _len, _ref;\n    ret = [];\n    _ref = this.keys();\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      k = _ref[_i];\n      ret.push(this.data[k]);\n    }\n    return ret;\n  };\n\n  Hash.prototype._fetch = function(k, defaultValue) {\n    var ret;\n    defaultValue = defaultValue === void 0 ? null : defaultValue;\n    ret = this.data[k];\n    if (ret === void 0) {\n      return defaultValue;\n    } else {\n      return ret;\n    }\n  };\n\n  Hash.prototype._store = function(k, v) {\n    return this.data[k] = v;\n  };\n\n  Hash.prototype._fetch_or_store = function(k, v) {\n    var _base;\n    if ((_base = this.data)[k] == null) _base[k] = v;\n    return this.data[k];\n  };\n\n  Hash.prototype._toHash = function() {\n    return this;\n  };\n\n  Hash.prototype._toObject = function() {\n    return new Object(this.data);\n  };\n\n  Hash.prototype._keys = function() {\n    var keys;\n    keys = [];\n    this._each(function(k) {\n      return keys.push(k);\n    });\n    return keys;\n  };\n\n  Hash.prototype._values = function() {\n    return this._map(function(k, v) {\n      return v;\n    });\n  };\n\n  Hash.prototype._hasKey = function(key) {\n    var ret;\n    ret = false;\n    this._each(function(k) {\n      if (k === key) {\n        ret = true;\n        throw BREAKER;\n      }\n    });\n    return ret;\n  };\n\n  Hash.prototype._hasValue = function(value) {\n    var ret;\n    ret = false;\n    this._each(function(k, v) {\n      if (v === value) {\n        ret = true;\n        throw BREAKER;\n      }\n    });\n    return ret;\n  };\n\n  return Hash;\n\n})(Object);\n\nHash.prototype._get = Hash.prototype._fetch;\n\nHash.prototype._set = Hash.prototype._store;\n\nHash.prototype._get_or_set = Hash.prototype._fetch_or_store;\n\n_.mixin(Hash, Enumerable);\n\nH = function(data) {\n  return new Hash(data);\n};\n\nroot['Hash'] = Hash;\n\nroot['H'] = H;\n\n})();\n//@ sourceURL=./hash");minispade.register('tagen', "(function() {minispade.require(\"./core\");\nminispade.require(\"./enumerable\");\nminispade.require(\"./hash\");\nminispade.require(\"./array\");\nminispade.require(\"./enumerator\");\nminispade.require(\"./string\");\nminispade.require(\"./math\");\nminispade.require(\"./number\");\n\n})();\n//@ sourceURL=tagen");minispade.register('./math', "(function() {\n_.reopenClass(Math, {\n  _mod: function(val, mod) {\n    if (val < 0) {\n      while (val < 0) {\n        val += mod;\n      }\n      return val;\n    } else {\n      return val % mod;\n    }\n  }\n});\n\n})();\n//@ sourceURL=./math");minispade.register('./number', "(function() {var __slice = Array.prototype.slice;\n\n_.reopenClass(Number, {\n  _max: function(a, b) {\n    if (a < b) {\n      return b;\n    } else {\n      return a;\n    }\n  },\n  _min: function(a, b) {\n    if (a > b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n});\n\n_.reopen(Number, {\n  _times: function() {\n    var args, callback, i, start, _ref, _results;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    switch (args.length) {\n      case 2:\n        start = args[0], callback = args[1];\n        break;\n      case 1:\n        _ref = [0, args[0]], start = _ref[0], callback = _ref[1];\n    }\n    _results = [];\n    for (i = 0; 0 <= this ? i < this : i > this; 0 <= this ? i++ : i--) {\n      _results.push(callback.call(this, start + i));\n    }\n    return _results;\n  },\n  _toInteger: function() {\n    return Math.floor(this);\n  },\n  _div: function(n) {\n    return (this / n)._toInteger();\n  },\n  _fdiv: function(n) {\n    return this / n;\n  }\n});\n\n})();\n//@ sourceURL=./number");minispade.register('./string', "(function() {\n_.reopen(String, {\n  _toInteger: function() {\n    return parseInt(this);\n  },\n  _pluralize: function() {\n    return \"\" + this + \"s\";\n  },\n  _capitalize: function() {\n    return this.charAt(0).toUpperCase() + this.slice(1);\n  },\n  _chop: function() {\n    if (this.length === 0) {\n      return \"\";\n    } else {\n      return this.substring(0, this.length - 1);\n    }\n  },\n  _endsWith: function(str) {\n    return this.length - str.length === this.lastIndexOf(str);\n  },\n  _reverse: function() {\n    var i, s;\n    s = \"\";\n    i = this.length;\n    while (i > 0) {\n      s += this.substring(i - 1, i);\n      i--;\n    }\n    return s;\n  },\n  _isEmpty: function() {\n    return this.length === 0;\n  }\n});\n\n})();\n//@ sourceURL=./string");